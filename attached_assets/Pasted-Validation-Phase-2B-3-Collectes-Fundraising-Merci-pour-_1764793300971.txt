Validation Phase 2B.3 â€“ Collectes / Fundraising

Merci pour le plan dÃ©taillÃ©, câ€™est exactement la logique que je veux.
Je valide la Phase 2B.3 avec les prÃ©cisions suivantes :

1ï¸âƒ£ Routes â†’ OK âœ…

Les signatures proposÃ©es me conviennent :

POST /api/collections

POST /api/payments/create-collection-session

GET /api/collections/:communityId

âœ… Ã€ garder important :

Pour POST /api/collections, la vÃ©rification userId admin/dÃ©lÃ©guÃ© avec canManageCollections = true est indispensable.

Si possible, utilise lâ€™utilisateur authentifiÃ© via la logique dâ€™auth existante plutÃ´t que de faire entiÃ¨rement confiance au userId passÃ© dans le body.

2ï¸âƒ£ Calcul de commission â†’ OK âœ…

Le calcul :

const feePercent = collection.platformFeePercent ?? community.platformFeePercent ?? 2;
const applicationFeeAmount = Math.round(amount * feePercent / 100);


me va trÃ¨s bien.

3ï¸âƒ£ Webhook payment_intent.succeeded â†’ une correction importante

La logique globale est bonne (crÃ©er transaction + mettre Ã  jour la collecte + fermer si objectif atteint).

Mais attention : dans ton pseudo-code tu utilises applicationFeeAmount dans le webhook alors quâ€™il nâ€™existe pas dans ce contexte.

â¡ï¸ Merci de rÃ©cupÃ©rer la commission Koomy directement depuis le PaymentIntent :

soit en lisant paymentIntent.application_fee_amount (si prÃ©sent),

soit en stockant le fee dans metadata au moment de la crÃ©ation de la session.

Par exemple dans le webhook :

const amountTotal = paymentIntent.amount;
const feeKoomy = paymentIntent.application_fee_amount || 0;
const amountToCommunity = amountTotal - feeKoomy;


Et ensuite :

await storage.insertTransaction({
  communityId,
  collectionId,
  membershipId,
  type: "collection",
  amountTotalCents: amountTotal,
  amountFeeKoomyCents: feeKoomy,
  amountToCommunity,
  currency: paymentIntent.currency?.toUpperCase() || "EUR",
  stripePaymentIntentId: paymentIntent.id,
  status: "succeeded",
  metadata: { communityId, collectionId, membershipId }
});


âš ï¸ Donc merci de ne pas utiliser une variable applicationFeeAmount non dÃ©finie dans le webhook, mais bien la valeur remontÃ©e par Stripe.

4ï¸âƒ£ Mise Ã  jour de la collecte â†’ OK âœ…

La logique suivante me va :

updateCollectionAmounts(collectionId, amountCents) :

incrÃ©mente collectedAmountCents de amountCents

incrÃ©mente participantsCount de 1

Si targetAmountCents est dÃ©fini et que collectedAmountCents >= targetAmountCents
â†’ passer la collecte en status = "closed" et remplir closedAt.

âœ… Oui, je veux que tu fermes automatiquement la collecte quand lâ€™objectif est atteint.

5ï¸âƒ£ GET /api/collections/:communityId â†’ OK âœ…

Retourner uniquement les collectes status = "open" pour lâ€™app membre.

Le calcul percentComplete cÃ´tÃ© backend ((collected / target) * 100) est parfait.

ğŸŸ¢ Conclusion

âœ… Les signatures de routes me conviennent.
âœ… Le calcul de commission avec prioritÃ© collection.platformFeePercent â†’ community.platformFeePercent â†’ 2% est validÃ©.
âœ… Oui, il faut fermer automatiquement la collecte quand lâ€™objectif est atteint.

Tu peux implÃ©menter la Phase 2B.3 maintenant,
en corrigeant le webhook pour utiliser paymentIntent.application_fee_amount (ou un Ã©quivalent) Ã  la place dâ€™une variable locale.